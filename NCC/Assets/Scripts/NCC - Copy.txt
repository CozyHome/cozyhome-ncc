using System;
using System.Collections.Generic;
using UnityEngine;

// nice data class that makes argument passing not cancer
public struct Move {
    public Vector3 pos;
    public Vector3 vel;
    public Vector3 scl;
    public readonly Quaternion rot;
    public readonly Collider self;
    public readonly float dt;

    public Move(float dt, Vector3 pos, Vector3 vel, Vector3 scl, Quaternion rot, Collider self) {
        this.dt = dt;
        this.pos = pos;
        this.vel = vel;
        this.rot = rot;
        this.scl = scl;
        this.self = self;
    }
}

public class NCC : MonoBehaviour {

    public Vector3 m_forw;
    public Transform m_cam;

    [SerializeField] [Range(-1F, 1F)] private float m_offs;
    private BoxCollider m_box;

    [SerializeField] private Vector4 m_veuler;

    private BoxCollider box {
        get {
            if(m_box == null)
                m_box = GetComponent<BoxCollider>();
            
            return m_box;
        }
    }

    private RaycastHit[] m_hbuf;
    private RaycastHit[] hbuf {
        get {
            if(m_hbuf == null)
                m_hbuf = new RaycastHit[16];
            
            return m_hbuf;
        }
    }

    private Collider[] m_cbuf;
    private Collider[] cbuf {
        get {
            if(m_cbuf == null)
                m_cbuf = new Collider[16];
            
            return m_cbuf;
        }
    }

    private List<Clip> m_clips;

    private List<Clip> clips {
        get {
            if(m_clips == null)
                m_clips = new List<Clip>();
            
            return m_clips;
        }
    }

    private void Start() {
        m_box = GetComponent<BoxCollider>();
        Application.targetFrameRate = 120;
    }

    private void Update() {
        if(!(Time.time > 0))
            return;

        Vector3 inp = new Vector3(Input.GetAxisRaw("Horizontal"), 0F, Input.GetAxisRaw("Vertical"));

        Vector3 move = m_cam.rotation * inp;
        float mv_mag = move.magnitude;
        m_forw = Vector3.ProjectOnPlane(move, Vector3.up);
        m_forw.Normalize();
        m_forw *= 5F;

        float up = Input.GetKey(KeyCode.Q) ? 1 : -1;
        up += Input.GetKey(KeyCode.E) ? -1 : 1;

        m_forw += Vector3.up * up;

        m_cam.position = Vector3.Lerp(m_cam.position, 
        this.transform.position - m_cam.forward * 5F,
        1 - Mathf.Exp(-30F * Time.deltaTime)
        );

    }

    private void FixedUpdate() {
        Move m = new Move(
            Time.fixedDeltaTime,
            box.transform.position, 
            m_forw,
            Vector3.Scale(box.size, transform.localScale), 
            box.transform.rotation,
            box
        );
        
        Slide(ref m);
        box.transform.position = m.pos;
    }

    private void OnDrawGizmos() {
    
    }

// collide & slide
    private void Slide(ref Move m) {
        ClipHull clist = new ClipHull(clips);

// resolve pushbacks
        OverlapBox(ref m, ref clist);
        m.vel = clist.ClipVector(m.vel);
        clist.Trim();

// trace primitive
        Complex_Trace(ref m, ref clist);
    }

void Complex_Trace(ref Move m, ref ClipHull clist) {
    const float bvel     = 1e-5f;
    const int max_bumps  = 8;

    var numbumps = 0;
    var tl = m.vel.magnitude * m.dt;
    var trace_dir = m.vel;

// simple trace movement
    while(tl > 0 && numbumps++ < max_bumps && trace_dir != Vector3.zero) {
        float tr = tl + 2F * m_offs;
        
        trace_dir.Normalize();
        int n = Physics.BoxCastNonAlloc(
            m.pos,
            m.scl / 2F,
            trace_dir,
            hbuf,
            m.rot,
            tr,
            (1 << 0),
            QueryTriggerInteraction.Ignore
        );

        n = TraceFilterSelf(n, m.self, hbuf);
        int i0 = FindClosest(n, hbuf);

        if(i0 < 0) {
            m.pos = m.pos + trace_dir * tl;
            break;
        }

// movement
// instead of 1. moving back along vector line with m_offs, or 2. moving back along normal of surface by m_offs:
// we combine these two approaches: we move backwards along the vector line such that the orthogonal distance to the plane is m_offs.
// this way we ensure we are m_offs units away from the surface while also not resulting in a protrusion into other nearby geometry
// as the vector we have traced ensures a valid path we can sweep along without intersecting other nearby geometry.
        RaycastHit cl = hbuf[i0];
        m.pos = m.pos + trace_dir * cl.distance;
        Vector3 np = m.pos + cl.normal * m_offs;
        tl = tl - (Vector3.Distance(np, m.pos) + cl.distance); 
        m.pos = m.pos - trace_dir * Vector3.Dot(np - m.pos, cl.normal);

// ClipNearest() takes care of hits that otherwise should have been accounted for as they are relatively close to
// our closest raycast hit.
        clist.AppendHit(cl);
        ClipNearest(i0, n, ref clist, hbuf);
        m.vel = clist.ClipVector(m.vel);
    
// we redirect velocity to not only be tangential to the surface plane, but also bounce it outwards to prevent generating
// near-tangential hits along an already resolved plane.
        m.vel += cl.normal * bvel;

// redirect trace_dir to be along our clipped vector line
        trace_dir = m.vel;
    }
}

    void OverlapBox(ref Move m, ref ClipHull clist) {
        int i = Physics.OverlapBoxNonAlloc(
            m.pos,
            m.scl / 2F,
            cbuf,
            m.rot,
            (1 << 0),
            QueryTriggerInteraction.Ignore
        );
    
        int res = OverlapFilterSelf(i, box, cbuf);
        ResolvePenetrations(ref m, res, ref clist, cbuf);
    }

// filter self
    int OverlapFilterSelf(int cnt, Collider s, Collider[] b) {
        for(int i = cnt - 1; i >= 0;i--) {
// are we ourself?
            if(b[i] == s) {
                cnt--;
// i is now below cnt, swap it with last entry 
                if(i < cnt)
                    b[i] = b[cnt];
            }else {
                continue;
            }
        }

        return cnt;
    }

// filter self
    int TraceFilterSelf(int cnt, Collider s, RaycastHit[] hbuf) {
        for(int i = cnt - 1; i >= 0;i--) {
// are we ourself?
            if(hbuf[i].collider == s) {
                cnt--;
// i is now below cnt, swap it with last entry 
                if(i < cnt)
                    hbuf[i] = hbuf[cnt];
            }else {
                continue;
            }
        }

        return cnt;
    }

// filter invalids and return index of closest hit 
    int FindClosest(int cnt, RaycastHit[] hbuf) {
        var min = float.MaxValue;
        int i0 = -1;
        for(int i = cnt - 1; i >= 0;i--) {
            float dist = hbuf[i].distance;
            if(dist > 0) {
                if(dist < min) {
                    min = dist;
                    i0 = i;
                }
            }
        }

        return i0;
    }

// find all distances that are relatively close to this distance and append them to clip list
    int ClipNearest(int i0, int cnt, ref ClipHull clist, RaycastHit[] hbuf) {
        var min = hbuf[i0].distance;
        var eps = 1e-3f;
        var n = 0;

        for(int i = cnt -1;i>=0;i--) {
            if(i == i0)
                continue;
            
            var dist = hbuf[i].distance;
            if(dist >= 0 && Mathf.Abs(min - dist) < eps) {
                clist.AppendHit(in hbuf[i]);
                n++;
            }
        }

        return n;
    }

// i assume unity uses some form of "GJK-EPA"-esque closest distance vector algorithm. It's not very useful outside of
// gathering whether we are already inside blocking geometry. this is usually the last place you want your solver
// to be as it means you didn't prevent a collision. -DC @ April 18th, 2021.
    void ResolvePenetrations(ref Move m, int res, ref ClipHull clist, Collider[] buf) {
        Transform s_t = m.self.GetComponent<Transform>();
        for(int i = 0;i < res;i++) {
            Collider c = buf[i];
            Transform c_t = c.GetComponent<Transform>();

            bool pen = Physics.ComputePenetration(
                m.self,
                m.pos,
                m.rot,
                c,
                c_t.position,
                c_t.rotation,
                out Vector3 sep,
                out float dist
            );

            if(pen) {
                clist.AppendOverlap(m.pos, sep, c, dist);
                m.pos += sep * dist;
            }
        }
    }

    public static void DrawRay(Vector3 p, Vector3 r, Color c) {
        if(Application.isPlaying) {
            Debug.DrawRay(p, r, c);
        }else {
            Gizmos.color = c;
            Gizmos.DrawRay(p, r);
        }
    }

    private void DrawBox(Vector3 position, Vector3 s, Quaternion q, BoxCollider box, Color c) {
        Gizmos.color = c;
        Gizmos.matrix = Matrix4x4.Translate(position) * Matrix4x4.Rotate(q);
        Gizmos.DrawWireCube(Vector3.zero, s);
        Gizmos.matrix = Matrix4x4.identity;
    }
}
